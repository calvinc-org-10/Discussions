#A django-q use case that isn't just sending e-mails
After YEARS of dodging it, I finally had to learn how to implement parts of a system asynchronously. My system, called WICS (Warehouse Inventory Control System), schedules and records physical inventories and facilitates comparison with SAP, which is the Source Of All Truth in my company. SAP stock-on-hand is exported through MB52 to a spreadsheet daily and imported into WICS. The Master Material List is exported from MM60 to a spreadsheet and used to update the WICS Material List once a month or so. Both of these processes involve queries that take a while to run, and the Material List update routinely takes long enough that my web server delivers a 504 (timeout) response.

The back-end of WICS is written in Python/Django.

While learning how to offload these lengthy queries to an async process, I searched for examples to guide me. Unfortunately, most async examples available focus on automating a recurring process, usually sending an email. While these examples were of some help, they left a lot of unanswered questions. I’m sure I’m not the first person with my use case, nor will I be the last. So here’s what I came up with, an example for the next sucker who has to figure out how to do this. I’m going to concentrate on the Material List update here, since that is the more complex of the functions that needed to go async.

Since I was going to offload the Material List update to an async process, I figured I’d also devise a scheme to update the web page client with the progress of the backend. More on that shortly.

Before this reworking, when the user asked to Update the Material List, a view called fnUpdateMatListfromSAP was run. It still is, but now instead of doing the entire update by itself, it offloads its work to a number of co-routines. The fnUpdateMatListfromSAP view and its supporting functions are all below. The template/HTML which sent the request (frmUpdateMatlListfromSAP_phase0.html) also had to undergo a few changes, primarily the addition of javascript which sends an ajax request (to fnUpdateMatlListfromSAP), then periodically listens for status updates from the server.

Before getting into my implementation of the Material List update, let me say a little about what I rejected and why.

When I first determined I needed to have Update Material List async, I said ‘async’, and the entire programming community responded ‘task queue and brokers’. At first I rejected this, because I wanted to depend on as few packages as possible.

So I looked at handling the async programming “directly” using async def/asyncio/await/etc. I rejected that because there was going to be way too much I had to implement, and my web host (PythonAnywhere) is WSGI-only, not ASGI. I saw a few blurbs about running async code in a WSGI environment, and the performance hits may be negligible, but for me, the learning curve was too steep and the work was more than I wanted to put in at this point. Looking at the work involved did have an upside, though: I better understood the idea of task queue and brokers. If I had done the async work in Python-only, I basically would have had to write a task queue and a broker, and what I would have developed would have been so dependent on each other and specific to this project that I would have had to totally rewrite it in another project, or if this one changed (WHEN this one changes!). PythonAnywhere’s WSGI-only server is also the reason I decided not to use any of Django’s async features, such as async views (which are just async functions anyhow)

So it was time to reconsider task queues and brokers. The task queue was actually easy. Celery seems to be the dominant task queue out there, but Celery isn’t supported on PythonAnywhere. The task queue PythonAnywhere supports and recommends is Django-q (they may support others, but the one mentioned in their help pages is django-q). For the broker, django-q supports using the ORM itself as a broker. The django-q docs caution that a more robust broker is appropriate for high-volume traffic, but WICS is not that. The ORM is adequate for my needs, and should WICS grow, I can switch to another broker.

If you are where I was when I started this journey, you may need to have all this task queue and broker stuff explained. This is how I understand it. When your view wants a task done asynchronously, it sends the task to the task queue, and then moves on to return an HttpResponse to the HttpRequest-er (the web page that sent the request that triggered your view). Depending on your needs, your view can schedule multiple async_tasks before returning a HttpResponse. Basically, your view is no longer responsible for doing the async_task, but simply passing it off (to the task queue) to be done. Running in the background is the broker, which picks up the async_task and places it in a Cluster. The Cluster picks off the tasks and runs them. This diagram, which seemed daunting at first, actually explains the process very well: https://django-q.readthedocs.io/en/latest/architecture.html

One of the things that was giving me pause was running an always-on task for the cluster. There are only two options in WICS which require asynchronous processing. One of those (the more time-consuming one) is typically run monthly, the other daily. The monthly process, slow as it is, typically completes in less than 15 (but far more than 3) minutes. I balked at having a process running 24/7 for 30 days when it will really be used for 15 minutes.

I’m very satisfied with my solution. The initial call to fnUpdateMatListfromSAP starts a django-q process and holds on to the pid (process id). While I’ve got it, I make the pid do double duty by being the key in my table which records and reports processing status. When all processing is complete and the results are presented, the result HTML/Javascript does a final ajax call to do cleanup: kill the status record for this run, kill the django-q process and delete the temporary table used to present results. This means my users cannot refresh the page containing the results, but that’s acceptable in my case.

=======

Later on I’ll explain the code below in some detail, but for now, I’ll simply present it with the hope that you will find either the code or the techniques useful.

Good luck!
